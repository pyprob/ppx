// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod ppx {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum MessageBody {
  NONE = 0,
  Handshake = 1,
  HandshakeResult = 2,
  Run = 3,
  RunResult = 4,
  Sample = 5,
  SampleResult = 6,
  Observe = 7,
  ObserveResult = 8,
  Tag = 9,
  TagResult = 10,
  Reset = 11,

}

pub const ENUM_MIN_MESSAGE_BODY: u8 = 0;
pub const ENUM_MAX_MESSAGE_BODY: u8 = 11;

impl<'a> flatbuffers::Follow<'a> for MessageBody {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for MessageBody {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const MessageBody;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const MessageBody;
    unsafe { *p }
  }
}

impl flatbuffers::Push for MessageBody {
    type Output = MessageBody;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<MessageBody>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_BODY:[MessageBody; 12] = [
  MessageBody::NONE,
  MessageBody::Handshake,
  MessageBody::HandshakeResult,
  MessageBody::Run,
  MessageBody::RunResult,
  MessageBody::Sample,
  MessageBody::SampleResult,
  MessageBody::Observe,
  MessageBody::ObserveResult,
  MessageBody::Tag,
  MessageBody::TagResult,
  MessageBody::Reset
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_MESSAGE_BODY:[&'static str; 12] = [
    "NONE",
    "Handshake",
    "HandshakeResult",
    "Run",
    "RunResult",
    "Sample",
    "SampleResult",
    "Observe",
    "ObserveResult",
    "Tag",
    "TagResult",
    "Reset"
];

pub fn enum_name_message_body(e: MessageBody) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_MESSAGE_BODY[index as usize]
}

pub struct MessageBodyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Distribution {
  NONE = 0,
  Normal = 1,
  Uniform = 2,
  Categorical = 3,
  Poisson = 4,

}

pub const ENUM_MIN_DISTRIBUTION: u8 = 0;
pub const ENUM_MAX_DISTRIBUTION: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for Distribution {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Distribution {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Distribution;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Distribution;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Distribution {
    type Output = Distribution;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Distribution>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DISTRIBUTION:[Distribution; 5] = [
  Distribution::NONE,
  Distribution::Normal,
  Distribution::Uniform,
  Distribution::Categorical,
  Distribution::Poisson
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DISTRIBUTION:[&'static str; 5] = [
    "NONE",
    "Normal",
    "Uniform",
    "Categorical",
    "Poisson"
];

pub fn enum_name_distribution(e: Distribution) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_DISTRIBUTION[index as usize]
}

pub struct DistributionUnionTableOffset {}
pub enum MessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      builder.add_body_type(args.body_type);
      builder.finish()
    }

    pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_BODY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn body_type(&self) -> MessageBody {
    self._tab.get::<MessageBody>(Message::VT_BODY_TYPE, Some(MessageBody::NONE)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_BODY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_handshake(&self) -> Option<Handshake<'a>> {
    if self.body_type() == MessageBody::Handshake {
      self.body().map(|u| Handshake::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_handshake_result(&self) -> Option<HandshakeResult<'a>> {
    if self.body_type() == MessageBody::HandshakeResult {
      self.body().map(|u| HandshakeResult::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_run(&self) -> Option<Run<'a>> {
    if self.body_type() == MessageBody::Run {
      self.body().map(|u| Run::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_run_result(&self) -> Option<RunResult<'a>> {
    if self.body_type() == MessageBody::RunResult {
      self.body().map(|u| RunResult::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_sample(&self) -> Option<Sample<'a>> {
    if self.body_type() == MessageBody::Sample {
      self.body().map(|u| Sample::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_sample_result(&self) -> Option<SampleResult<'a>> {
    if self.body_type() == MessageBody::SampleResult {
      self.body().map(|u| SampleResult::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_observe(&self) -> Option<Observe<'a>> {
    if self.body_type() == MessageBody::Observe {
      self.body().map(|u| Observe::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_observe_result(&self) -> Option<ObserveResult<'a>> {
    if self.body_type() == MessageBody::ObserveResult {
      self.body().map(|u| ObserveResult::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_tag(&self) -> Option<Tag<'a>> {
    if self.body_type() == MessageBody::Tag {
      self.body().map(|u| Tag::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_tag_result(&self) -> Option<TagResult<'a>> {
    if self.body_type() == MessageBody::TagResult {
      self.body().map(|u| TagResult::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_reset(&self) -> Option<Reset<'a>> {
    if self.body_type() == MessageBody::Reset {
      self.body().map(|u| Reset::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct MessageArgs {
    pub body_type: MessageBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            body_type: MessageBody::NONE,
            body: None,
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_body_type(&mut self, body_type: MessageBody) {
    self.fbb_.push_slot::<MessageBody>(Message::VT_BODY_TYPE, body_type, MessageBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TensorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
    type Inner = Tensor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Tensor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Tensor {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TensorArgs<'args>) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
      let mut builder = TensorBuilder::new(_fbb);
      if let Some(x) = args.shape { builder.add_shape(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Tensor::VT_DATA, None)
  }
  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Tensor::VT_SHAPE, None)
  }
}

pub struct TensorArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f64>>>,
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  i32>>>,
}
impl<'a> Default for TensorArgs<'a> {
    #[inline]
    fn default() -> Self {
        TensorArgs {
            data: None,
            shape: None,
        }
    }
}
pub struct TensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_DATA, data);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HandshakeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Handshake<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Handshake<'a> {
    type Inner = Handshake<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Handshake<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Handshake {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HandshakeArgs<'args>) -> flatbuffers::WIPOffset<Handshake<'bldr>> {
      let mut builder = HandshakeBuilder::new(_fbb);
      if let Some(x) = args.system_name { builder.add_system_name(x); }
      builder.finish()
    }

    pub const VT_SYSTEM_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn system_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Handshake::VT_SYSTEM_NAME, None)
  }
}

pub struct HandshakeArgs<'a> {
    pub system_name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for HandshakeArgs<'a> {
    #[inline]
    fn default() -> Self {
        HandshakeArgs {
            system_name: None,
        }
    }
}
pub struct HandshakeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HandshakeBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_name(&mut self, system_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Handshake::VT_SYSTEM_NAME, system_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HandshakeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HandshakeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Handshake<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HandshakeResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct HandshakeResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HandshakeResult<'a> {
    type Inner = HandshakeResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> HandshakeResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HandshakeResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HandshakeResultArgs<'args>) -> flatbuffers::WIPOffset<HandshakeResult<'bldr>> {
      let mut builder = HandshakeResultBuilder::new(_fbb);
      if let Some(x) = args.model_name { builder.add_model_name(x); }
      if let Some(x) = args.system_name { builder.add_system_name(x); }
      builder.finish()
    }

    pub const VT_SYSTEM_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_MODEL_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn system_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HandshakeResult::VT_SYSTEM_NAME, None)
  }
  #[inline]
  pub fn model_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HandshakeResult::VT_MODEL_NAME, None)
  }
}

pub struct HandshakeResultArgs<'a> {
    pub system_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub model_name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for HandshakeResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        HandshakeResultArgs {
            system_name: None,
            model_name: None,
        }
    }
}
pub struct HandshakeResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HandshakeResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_name(&mut self, system_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HandshakeResult::VT_SYSTEM_NAME, system_name);
  }
  #[inline]
  pub fn add_model_name(&mut self, model_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HandshakeResult::VT_MODEL_NAME, model_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HandshakeResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HandshakeResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HandshakeResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Run<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Run<'a> {
    type Inner = Run<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Run<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Run {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args RunArgs) -> flatbuffers::WIPOffset<Run<'bldr>> {
      let mut builder = RunBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct RunArgs {
}
impl<'a> Default for RunArgs {
    #[inline]
    fn default() -> Self {
        RunArgs {
        }
    }
}
pub struct RunBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Run<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RunResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RunResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunResult<'a> {
    type Inner = RunResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RunResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RunResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RunResultArgs<'args>) -> flatbuffers::WIPOffset<RunResult<'bldr>> {
      let mut builder = RunResultBuilder::new(_fbb);
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn result(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(RunResult::VT_RESULT, None)
  }
}

pub struct RunResultArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for RunResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        RunResultArgs {
            result: None,
        }
    }
}
pub struct RunResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(RunResult::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SampleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Sample<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sample<'a> {
    type Inner = Sample<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Sample<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Sample {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SampleArgs<'args>) -> flatbuffers::WIPOffset<Sample<'bldr>> {
      let mut builder = SampleBuilder::new(_fbb);
      if let Some(x) = args.distribution { builder.add_distribution(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.add_replace(args.replace);
      builder.add_control(args.control);
      builder.add_distribution_type(args.distribution_type);
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISTRIBUTION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DISTRIBUTION: flatbuffers::VOffsetT = 10;
    pub const VT_CONTROL: flatbuffers::VOffsetT = 12;
    pub const VT_REPLACE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sample::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sample::VT_NAME, None)
  }
  #[inline]
  pub fn distribution_type(&self) -> Distribution {
    self._tab.get::<Distribution>(Sample::VT_DISTRIBUTION_TYPE, Some(Distribution::NONE)).unwrap()
  }
  #[inline]
  pub fn distribution(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Sample::VT_DISTRIBUTION, None)
  }
  #[inline]
  pub fn control(&self) -> bool {
    self._tab.get::<bool>(Sample::VT_CONTROL, Some(true)).unwrap()
  }
  #[inline]
  pub fn replace(&self) -> bool {
    self._tab.get::<bool>(Sample::VT_REPLACE, Some(false)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_normal(&self) -> Option<Normal<'a>> {
    if self.distribution_type() == Distribution::Normal {
      self.distribution().map(|u| Normal::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_uniform(&self) -> Option<Uniform<'a>> {
    if self.distribution_type() == Distribution::Uniform {
      self.distribution().map(|u| Uniform::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_categorical(&self) -> Option<Categorical<'a>> {
    if self.distribution_type() == Distribution::Categorical {
      self.distribution().map(|u| Categorical::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_poisson(&self) -> Option<Poisson<'a>> {
    if self.distribution_type() == Distribution::Poisson {
      self.distribution().map(|u| Poisson::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct SampleArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub distribution_type: Distribution,
    pub distribution: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub control: bool,
    pub replace: bool,
}
impl<'a> Default for SampleArgs<'a> {
    #[inline]
    fn default() -> Self {
        SampleArgs {
            address: None,
            name: None,
            distribution_type: Distribution::NONE,
            distribution: None,
            control: true,
            replace: false,
        }
    }
}
pub struct SampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_NAME, name);
  }
  #[inline]
  pub fn add_distribution_type(&mut self, distribution_type: Distribution) {
    self.fbb_.push_slot::<Distribution>(Sample::VT_DISTRIBUTION_TYPE, distribution_type, Distribution::NONE);
  }
  #[inline]
  pub fn add_distribution(&mut self, distribution: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_DISTRIBUTION, distribution);
  }
  #[inline]
  pub fn add_control(&mut self, control: bool) {
    self.fbb_.push_slot::<bool>(Sample::VT_CONTROL, control, true);
  }
  #[inline]
  pub fn add_replace(&mut self, replace: bool) {
    self.fbb_.push_slot::<bool>(Sample::VT_REPLACE, replace, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sample<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SampleResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SampleResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SampleResult<'a> {
    type Inner = SampleResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SampleResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SampleResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SampleResultArgs<'args>) -> flatbuffers::WIPOffset<SampleResult<'bldr>> {
      let mut builder = SampleResultBuilder::new(_fbb);
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn result(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(SampleResult::VT_RESULT, None)
  }
}

pub struct SampleResultArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for SampleResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        SampleResultArgs {
            result: None,
        }
    }
}
pub struct SampleResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SampleResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(SampleResult::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SampleResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SampleResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SampleResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ObserveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Observe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Observe<'a> {
    type Inner = Observe<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Observe<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Observe {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ObserveArgs<'args>) -> flatbuffers::WIPOffset<Observe<'bldr>> {
      let mut builder = ObserveBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.distribution { builder.add_distribution(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.add_distribution_type(args.distribution_type);
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISTRIBUTION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DISTRIBUTION: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Observe::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Observe::VT_NAME, None)
  }
  #[inline]
  pub fn distribution_type(&self) -> Distribution {
    self._tab.get::<Distribution>(Observe::VT_DISTRIBUTION_TYPE, Some(Distribution::NONE)).unwrap()
  }
  #[inline]
  pub fn distribution(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Observe::VT_DISTRIBUTION, None)
  }
  #[inline]
  pub fn value(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Observe::VT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_normal(&self) -> Option<Normal<'a>> {
    if self.distribution_type() == Distribution::Normal {
      self.distribution().map(|u| Normal::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_uniform(&self) -> Option<Uniform<'a>> {
    if self.distribution_type() == Distribution::Uniform {
      self.distribution().map(|u| Uniform::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_categorical(&self) -> Option<Categorical<'a>> {
    if self.distribution_type() == Distribution::Categorical {
      self.distribution().map(|u| Categorical::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_poisson(&self) -> Option<Poisson<'a>> {
    if self.distribution_type() == Distribution::Poisson {
      self.distribution().map(|u| Poisson::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ObserveArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub distribution_type: Distribution,
    pub distribution: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub value: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for ObserveArgs<'a> {
    #[inline]
    fn default() -> Self {
        ObserveArgs {
            address: None,
            name: None,
            distribution_type: Distribution::NONE,
            distribution: None,
            value: None,
        }
    }
}
pub struct ObserveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObserveBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_NAME, name);
  }
  #[inline]
  pub fn add_distribution_type(&mut self, distribution_type: Distribution) {
    self.fbb_.push_slot::<Distribution>(Observe::VT_DISTRIBUTION_TYPE, distribution_type, Distribution::NONE);
  }
  #[inline]
  pub fn add_distribution(&mut self, distribution: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_DISTRIBUTION, distribution);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Observe::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObserveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObserveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Observe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ObserveResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ObserveResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ObserveResult<'a> {
    type Inner = ObserveResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ObserveResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ObserveResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ObserveResultArgs) -> flatbuffers::WIPOffset<ObserveResult<'bldr>> {
      let mut builder = ObserveResultBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct ObserveResultArgs {
}
impl<'a> Default for ObserveResultArgs {
    #[inline]
    fn default() -> Self {
        ObserveResultArgs {
        }
    }
}
pub struct ObserveResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObserveResultBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObserveResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObserveResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ObserveResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TagOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Tag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
    type Inner = Tag<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Tag<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Tag {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TagArgs<'args>) -> flatbuffers::WIPOffset<Tag<'bldr>> {
      let mut builder = TagBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Tag::VT_VALUE, None)
  }
}

pub struct TagArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for TagArgs<'a> {
    #[inline]
    fn default() -> Self {
        TagArgs {
            address: None,
            name: None,
            value: None,
        }
    }
}
pub struct TagBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TagBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Tag::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TagResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TagResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TagResult<'a> {
    type Inner = TagResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TagResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TagResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args TagResultArgs) -> flatbuffers::WIPOffset<TagResult<'bldr>> {
      let mut builder = TagResultBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct TagResultArgs {
}
impl<'a> Default for TagResultArgs {
    #[inline]
    fn default() -> Self {
        TagResultArgs {
        }
    }
}
pub struct TagResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TagResultBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TagResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TagResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ResetOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Reset<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Reset<'a> {
    type Inner = Reset<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Reset<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Reset {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ResetArgs) -> flatbuffers::WIPOffset<Reset<'bldr>> {
      let mut builder = ResetBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct ResetArgs {
}
impl<'a> Default for ResetArgs {
    #[inline]
    fn default() -> Self {
        ResetArgs {
        }
    }
}
pub struct ResetBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResetBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResetBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Reset<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NormalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Normal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Normal<'a> {
    type Inner = Normal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Normal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Normal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NormalArgs<'args>) -> flatbuffers::WIPOffset<Normal<'bldr>> {
      let mut builder = NormalBuilder::new(_fbb);
      if let Some(x) = args.stddev { builder.add_stddev(x); }
      if let Some(x) = args.mean { builder.add_mean(x); }
      builder.finish()
    }

    pub const VT_MEAN: flatbuffers::VOffsetT = 4;
    pub const VT_STDDEV: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn mean(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Normal::VT_MEAN, None)
  }
  #[inline]
  pub fn stddev(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Normal::VT_STDDEV, None)
  }
}

pub struct NormalArgs<'a> {
    pub mean: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
    pub stddev: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for NormalArgs<'a> {
    #[inline]
    fn default() -> Self {
        NormalArgs {
            mean: None,
            stddev: None,
        }
    }
}
pub struct NormalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NormalBuilder<'a, 'b> {
  #[inline]
  pub fn add_mean(&mut self, mean: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Normal::VT_MEAN, mean);
  }
  #[inline]
  pub fn add_stddev(&mut self, stddev: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Normal::VT_STDDEV, stddev);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NormalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NormalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Normal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UniformOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Uniform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uniform<'a> {
    type Inner = Uniform<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Uniform<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uniform {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UniformArgs<'args>) -> flatbuffers::WIPOffset<Uniform<'bldr>> {
      let mut builder = UniformBuilder::new(_fbb);
      if let Some(x) = args.high { builder.add_high(x); }
      if let Some(x) = args.low { builder.add_low(x); }
      builder.finish()
    }

    pub const VT_LOW: flatbuffers::VOffsetT = 4;
    pub const VT_HIGH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn low(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Uniform::VT_LOW, None)
  }
  #[inline]
  pub fn high(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Uniform::VT_HIGH, None)
  }
}

pub struct UniformArgs<'a> {
    pub low: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
    pub high: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for UniformArgs<'a> {
    #[inline]
    fn default() -> Self {
        UniformArgs {
            low: None,
            high: None,
        }
    }
}
pub struct UniformBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UniformBuilder<'a, 'b> {
  #[inline]
  pub fn add_low(&mut self, low: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Uniform::VT_LOW, low);
  }
  #[inline]
  pub fn add_high(&mut self, high: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Uniform::VT_HIGH, high);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UniformBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UniformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uniform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CategoricalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Categorical<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Categorical<'a> {
    type Inner = Categorical<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Categorical<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Categorical {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CategoricalArgs<'args>) -> flatbuffers::WIPOffset<Categorical<'bldr>> {
      let mut builder = CategoricalBuilder::new(_fbb);
      if let Some(x) = args.probs { builder.add_probs(x); }
      builder.finish()
    }

    pub const VT_PROBS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn probs(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Categorical::VT_PROBS, None)
  }
}

pub struct CategoricalArgs<'a> {
    pub probs: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for CategoricalArgs<'a> {
    #[inline]
    fn default() -> Self {
        CategoricalArgs {
            probs: None,
        }
    }
}
pub struct CategoricalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CategoricalBuilder<'a, 'b> {
  #[inline]
  pub fn add_probs(&mut self, probs: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Categorical::VT_PROBS, probs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CategoricalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CategoricalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Categorical<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PoissonOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Poisson<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Poisson<'a> {
    type Inner = Poisson<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Poisson<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Poisson {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PoissonArgs<'args>) -> flatbuffers::WIPOffset<Poisson<'bldr>> {
      let mut builder = PoissonBuilder::new(_fbb);
      if let Some(x) = args.rate { builder.add_rate(x); }
      builder.finish()
    }

    pub const VT_RATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rate(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor<'a>>>(Poisson::VT_RATE, None)
  }
}

pub struct PoissonArgs<'a> {
    pub rate: Option<flatbuffers::WIPOffset<Tensor<'a >>>,
}
impl<'a> Default for PoissonArgs<'a> {
    #[inline]
    fn default() -> Self {
        PoissonArgs {
            rate: None,
        }
    }
}
pub struct PoissonBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PoissonBuilder<'a, 'b> {
  #[inline]
  pub fn add_rate(&mut self, rate: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Poisson::VT_RATE, rate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PoissonBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PoissonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Poisson<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_root::<Message<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_size_prefixed_root::<Message<'a>>(buf)
}

pub const MESSAGE_IDENTIFIER: &'static str = "PPXF";

#[inline]
pub fn message_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, MESSAGE_IDENTIFIER, false);
}

#[inline]
pub fn message_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, MESSAGE_IDENTIFIER, true);
}

#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, Some(MESSAGE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, Some(MESSAGE_IDENTIFIER));
}
}  // pub mod ppx

